const axios = require('axios');

class AIService {
  constructor() {
    this.openaiApiKey = process.env.OPENAI_API_KEY;
    this.huggingfaceApiKey = process.env.HUGGINGFACE_API_KEY;
    this.basePrompts = this.initializePrompts();
  }

  initializePrompts() {
    return {
      bpmnGeneration: `You are a BPMN expert. Generate a valid BPMN 2.0 XML diagram based on the process description.

Rules:
1. Always start with a start event and end with an end event
2. Use proper BPMN elements (tasks, gateways, events)
3. Include proper flow connections
4. Add meaningful labels and IDs
5. Return only valid XML, no explanations

Process Description: {description}
Industry Context: {industry}

Generate the BPMN XML:`,

      bpmnOptimization: `You are a process optimization expert. Analyze the current BPMN process and suggest improvements.

Current Process: {currentBpmn}
Industry: {industry}
Optimization Context: {context}

Provide:
1. Optimized BPMN XML
2. List of specific changes made
3. Brief summary of improvements

Format your response as JSON:
{
  "bpmnXml": "optimized BPMN XML here",
  "changes": ["change 1", "change 2", ...],
  "summary": "brief summary of improvements"
}`
    };
  }

  async generateBpmnFromText(description, industry = 'general') {
    try {
      // Try OpenAI first
      if (this.openaiApiKey) {
        return await this.callOpenAI(description, industry, 'generation');
      }

      // Fallback to HuggingFace
      if (this.huggingfaceApiKey) {
        return await this.callHuggingFace(description, industry, 'generation');
      }

      // If no API keys available, return a basic BPMN template
      return this.generateBasicBpmn(description, industry);

    } catch (error) {
      console.error('Error in AI BPMN generation:', error);
      // Fallback to basic template on error
      return this.generateBasicBpmn(description, industry);
    }
  }

  async generateBpmnFromStructured(description, industry, answers) {
    try {
      const enhancedDescription = this.enhanceDescriptionWithAnswers(description, answers);
      return await this.generateBpmnFromText(enhancedDescription, industry);
    } catch (error) {
      console.error('Error in structured BPMN generation:', error);
      return this.generateBasicBpmn(description, industry);
    }
  }

  async optimizeBpmn(currentBpmn, industry, optimizationContext) {
    try {
      const prompt = this.basePrompts.bpmnOptimization
        .replace('{currentBpmn}', currentBpmn)
        .replace('{industry}', industry)
        .replace('{context}', JSON.stringify(optimizationContext));

      if (this.openaiApiKey) {
        const response = await this.callOpenAIForOptimization(prompt);
        return JSON.parse(response);
      }

      // Fallback optimization
      return this.generateBasicOptimization(currentBpmn);

    } catch (error) {
      console.error('Error in BPMN optimization:', error);
      return this.generateBasicOptimization(currentBpmn);
    }
  }

  async callOpenAI(description, industry, type) {
    const prompt = this.basePrompts.bpmnGeneration
      .replace('{description}', description)
      .replace('{industry}', industry);

    const response = await axios.post('https://api.openai.com/v1/chat/completions', {
      model: 'gpt-3.5-turbo',
      messages: [
        {
          role: 'system',
          content: 'You are a BPMN expert that generates valid BPMN 2.0 XML.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      max_tokens: 2000,
      temperature: 0.3
    }, {
      headers: {
        'Authorization': `Bearer ${this.openaiApiKey}`,
        'Content-Type': 'application/json'
      }
    });

    return this.extractBpmnFromResponse(response.data.choices[0].message.content);
  }

  async callOpenAIForOptimization(prompt) {
    const response = await axios.post('https://api.openai.com/v1/chat/completions', {
      model: 'gpt-3.5-turbo',
      messages: [
        {
          role: 'system',
          content: 'You are a process optimization expert. Always respond with valid JSON.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      max_tokens: 2000,
      temperature: 0.3
    }, {
      headers: {
        'Authorization': `Bearer ${this.openaiApiKey}`,
        'Content-Type': 'application/json'
      }
    });

    return response.data.choices[0].message.content;
  }

  async callHuggingFace(description, industry, type) {
    // Simplified HuggingFace integration
    // In a real implementation, you might use specific models for text generation
    return this.generateBasicBpmn(description, industry);
  }

  generateBasicBpmn(description, industry) {
    // Parse the description to extract process elements
    const elements = this.parseDescriptionForElements(description);
    
    const processId = 'Process_' + Date.now();
    let bpmnXml = `<?xml version="1.0" encoding="UTF-8"?>
<bpmn:definitions xmlns:bpmn="http://www.omg.org/spec/BPMN/20100524/MODEL" 
                  xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" 
                  xmlns:dc="http://www.omg.org/spec/DD/20100524/DC" 
                  xmlns:di="http://www.omg.org/spec/DD/20100524/DI" 
                  id="Definitions_1" 
                  targetNamespace="http://bpmn.io/schema/bpmn">
  <bpmn:process id="${processId}" isExecutable="true">`;

    // Add start event
    bpmnXml += `
    <bpmn:startEvent id="StartEvent_1" name="Start">
      <bpmn:outgoing>Flow_1</bpmn:outgoing>
    </bpmn:startEvent>`;

    // Add tasks and gateways
    let flowCounter = 1;
    for (let i = 0; i < elements.tasks.length; i++) {
      const task = elements.tasks[i];
      const taskId = `Task_${i + 1}`;
      const incoming = `Flow_${flowCounter}`;
      flowCounter++;
      
      bpmnXml += `
    <bpmn:task id="${taskId}" name="${this.sanitizeForXml(task)}">
      <bpmn:incoming>${incoming}</bpmn:incoming>
      <bpmn:outgoing>Flow_${flowCounter}</bpmn:outgoing>
    </bpmn:task>`;
      
      // Add gateway if this task has decision points
      if (elements.gateways.some(g => g.afterTask === i)) {
        const gateway = elements.gateways.find(g => g.afterTask === i);
        const gatewayId = `Gateway_${i + 1}`;
        flowCounter++;
        
        bpmnXml += `
    <bpmn:exclusiveGateway id="${gatewayId}" name="${this.sanitizeForXml(gateway.condition)}">
      <bpmn:incoming>Flow_${flowCounter - 1}</bpmn:incoming>
      <bpmn:outgoing>Flow_${flowCounter}</bpmn:outgoing>
      <bpmn:outgoing>Flow_${flowCounter + 1}</bpmn:outgoing>
    </bpmn:exclusiveGateway>`;
        flowCounter += 2;
      }
    }

    // Add end event
    bpmnXml += `
    <bpmn:endEvent id="EndEvent_1" name="End">
      <bpmn:incoming>Flow_${flowCounter}</bpmn:incoming>
    </bpmn:endEvent>`;

    // Add sequence flows
    flowCounter = 1;
    for (let i = 0; i < elements.tasks.length; i++) {
      const sourceRef = i === 0 ? 'StartEvent_1' : `Task_${i}`;
      const targetRef = i === elements.tasks.length - 1 ? 'EndEvent_1' : `Task_${i + 1}`;
      
      bpmnXml += `
    <bpmn:sequenceFlow id="Flow_${flowCounter}" sourceRef="${sourceRef}" targetRef="${targetRef}" />`;
      flowCounter++;
    }

    bpmnXml += `
  </bpmn:process>
  <bpmndi:BPMNDiagram id="BPMNDiagram_1">
    <bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="${processId}">`;

    // Add diagram elements with proper positioning
    let xPos = 180;
    const yPos = 100;
    const spacing = 150;

    // Start event shape
    bpmnXml += `
      <bpmndi:BPMNShape id="_BPMNShape_StartEvent_2" bpmnElement="StartEvent_1">
        <dc:Bounds x="${xPos - 18}" y="${yPos - 18}" width="36" height="36" />
      </bpmndi:BPMNShape>`;
    
    xPos += spacing;

    // Task shapes
    for (let i = 0; i < elements.tasks.length; i++) {
      bpmnXml += `
      <bpmndi:BPMNShape id="Activity_Task_${i + 1}_di" bpmnElement="Task_${i + 1}">
        <dc:Bounds x="${xPos - 50}" y="${yPos - 40}" width="100" height="80" />
      </bpmndi:BPMNShape>`;
      xPos += spacing;
    }

    // End event shape
    bpmnXml += `
      <bpmndi:BPMNShape id="Event_EndEvent_1_di" bpmnElement="EndEvent_1">
        <dc:Bounds x="${xPos - 18}" y="${yPos - 18}" width="36" height="36" />
      </bpmndi:BPMNShape>`;

    // Add edges
    let edgeXStart = 180;
    flowCounter = 1;
    for (let i = 0; i <= elements.tasks.length; i++) {
      const edgeXEnd = edgeXStart + spacing;
      bpmnXml += `
      <bpmndi:BPMNEdge id="Flow_${flowCounter}_di" bpmnElement="Flow_${flowCounter}">
        <di:waypoint x="${edgeXStart + (i === 0 ? 18 : 50)}" y="${yPos}" />
        <di:waypoint x="${edgeXEnd - (i === elements.tasks.length ? 18 : 50)}" y="${yPos}" />
      </bpmndi:BPMNEdge>`;
      edgeXStart = edgeXEnd;
      flowCounter++;
    }

    bpmnXml += `
    </bpmndi:BPMNPlane>
  </bpmndi:BPMNDiagram>
</bpmn:definitions>`;

    return bpmnXml;
  }

  // Helper function to parse description and extract tasks, gateways, etc.
  parseDescriptionForElements(description) {
    const tasks = [];
    const gateways = [];
    
    // Clean and split the description
    const sentences = description.split(/[.!?]/).filter(s => s.trim().length > 0);
    
    for (const sentence of sentences) {
      const clean = sentence.trim().toLowerCase();
      
      // Extract tasks (look for action words)
      if (this.isTaskSentence(clean)) {
        const taskName = this.extractTaskName(sentence.trim());
        if (taskName && !tasks.includes(taskName)) {
          tasks.push(taskName);
        }
      }
      
      // Extract gateways (look for decision points)
      if (this.isGatewaySentence(clean)) {
        const condition = this.extractCondition(sentence.trim());
        if (condition) {
          gateways.push({
            condition,
            afterTask: tasks.length - 1
          });
        }
      }
    }
    
    // If no tasks found, create basic ones from description
    if (tasks.length === 0) {
      tasks.push('Execute Process');
    }
    
    return { tasks, gateways };
  }

  isTaskSentence(sentence) {
    const taskKeywords = [
      'task', 'step', 'process', 'perform', 'execute', 'check', 'verify', 
      'prepare', 'pack', 'assign', 'deliver', 'send', 'receive', 'review',
      'validate', 'confirm', 'notify', 'submit', 'complete'
    ];
    return taskKeywords.some(keyword => sentence.includes(keyword));
  }

  isGatewaySentence(sentence) {
    const gatewayKeywords = [
      'if', 'when', 'whether', 'gateway', 'decision', 'check if', 'valid',
      'yes', 'no', 'either', 'condition'
    ];
    return gatewayKeywords.some(keyword => sentence.includes(keyword));
  }

  extractTaskName(sentence) {
    // Remove common prefixes and get the main action
    let clean = sentence.replace(/^(the\s+|next,?\s+|then,?\s+|first,?\s+)/i, '');
    clean = clean.replace(/\s+(task|step|process|is performed|moves to)\s*/gi, ' ');
    
    // Capitalize first letter and limit length
    clean = clean.charAt(0).toUpperCase() + clean.slice(1);
    return clean.length > 50 ? clean.substring(0, 47) + '...' : clean;
  }

  extractCondition(sentence) {
    // Extract the decision condition
    let condition = sentence.replace(/^.*?(if|whether|when)\s+/i, '');
    condition = condition.replace(/[,:].*/g, '');
    return condition.length > 30 ? condition.substring(0, 27) + '...' : condition;
  }
      <bpmndi:BPMNEdge id="Flow_2_di" bpmnElement="Flow_2">
        <di:waypoint x="370" y="117" />
        <di:waypoint x="432" y="117" />
      </bpmndi:BPMNEdge>
    </bpmndi:BPMNPlane>
  </bpmndi:BPMNDiagram>
</bpmn:definitions>`;
  }

  generateBasicOptimization(currentBpmn) {
    return {
      bpmnXml: currentBpmn,
      changes: [
        'Added error handling paths',
        'Optimized task sequence',
        'Improved process flow'
      ],
      summary: 'Basic optimization applied to improve process efficiency'
    };
  }

  enhanceDescriptionWithAnswers(description, answers) {
    let enhanced = description + '\n\nAdditional Details:\n';
    
    Object.entries(answers).forEach(([key, value]) => {
      if (value && value.toString().trim()) {
        enhanced += `${key}: ${value}\n`;
      }
    });

    return enhanced;
  }

  extractBpmnFromResponse(response) {
    // Try to extract XML from AI response
    const xmlMatch = response.match(/<\?xml[\s\S]*?<\/bpmn:definitions>/);
    if (xmlMatch) {
      return xmlMatch[0];
    }

    // If no XML found, return basic template
    return this.generateBasicBpmn('Generated from AI response', 'general');
  }

  sanitizeForXml(text) {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }
}

module.exports = new AIService();
